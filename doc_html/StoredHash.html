<html><head><title>StoredHash</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://search.cpan.org/s/style.css">

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Sat Dec 20 17:33:48 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#GENERAL_INFO_ON_StoredHash_PERSISTENCE'>GENERAL INFO ON StoredHash PERSISTENCE</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%24shp_%3D_StoredHash-%3Enew(%25opts)%3B'>$shp = StoredHash-&#62;new(%opts);</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Eerrstr(%24v)'>$shp-&#62;errstr($v)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Einsert(%24e)'>$shp-&#62;insert($e)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Eupdate(%24e%2C_%24ids%2C_%25opts)%3B'>$shp-&#62;update($e, $ids, %opts);</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Edelete(%24ids)_OR_%24shp-%3Edelete(%24filter)'>$shp-&#62;delete($ids) OR $shp-&#62;delete($filter)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Eexists(%24ids)'>$shp-&#62;exists($ids)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Eload(%24ids)'>$shp-&#62;load($ids)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Eloadset(%24filter%2C_%24sort%2C_%25opts)%3B'>$shp-&#62;loadset($filter, $sort, %opts);</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Ecols(%25opts)'>$shp-&#62;cols(%opts)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Ecount(%24filter)'>$shp-&#62;count($filter)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#INTERNAL_METHODS'>INTERNAL METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%40pkv_%3D_%24shp-%3Epkeyvals(%24e)'>@pkv = $shp-&#62;pkeyvals($e)</a>
    <li class='indexItem indexItem2'><a href='#%24shp-%3Ewhereid(%24pkvals)%3B'>$shp-&#62;whereid($pkvals);</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>StoredHash - Minimalistic,
yet fairly complete DBI Persister with a definite NoSQL feel to it</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>   use StoredHash;
   use DBI;
   use Data::Dumper;
   
   my $dbh = DBI-&#62;connect(&#34;dbi:SQLite:dbname=/tmp/zoo.db&#34;);
   # Lightweight demonstration of StoredHash in action (with SQLite)
   $dbh-&#62;do(&#34;CREATE TABLE animals (speciesid INTEGER NOT NULL PRIMARY KEY, name CHAR(16), limbcnt INTEGER, family CHAR(16))&#34;);
   my $shp = StoredHash-&#62;new(&#39;table&#39; =&#62; &#39;animals&#39;, &#39;pkey&#39; =&#62; [&#39;speciesid&#39;],
      &#39;autoid&#39; =&#62; 1, &#39;dbh&#39; =&#62; $dbh, &#39;debug&#39; =&#62; 0);
   # Hash object to be stored
   my $monkey = {&#39;name&#39; =&#62; &#39;Common Monkey&#39;, &#39;limbcnt&#39; =&#62; 5, &#39;family&#39; =&#62; &#39;mammal&#39;,};
   
   # Happens to return numeric id (because of auto-increment pkey / autoid)
   my $spid = $shp-&#62;insert($monkey);
   print(&#34;Created by: id=$spid\n&#34;);
   # Load entry
   my $ent = $shp-&#62;load([$spid]);
   print(&#34;Fetched (by $spid): &#34;.Dumper($ent).&#34;\n&#34;);
   # Get: {&#39;name&#39; =&#62; &#39;Common Monkey&#39;, &#39;speciesid&#39; =&#62; 469, &#39;limbcnt&#39; =&#62; 5,&#39;family&#39; =&#62; &#39;mammal&#39;,}
   # Fix error in entry (don&#39;t count tail to be limb)
   $ent-&#62;{&#39;limbcnt&#39;} = 4;
   # Update (with some redundant attributes that do not change)
   print(&#34;Update $ent-&#62;{&#39;speciesid&#39;}\n&#34;);
   $shp-&#62;update($ent, [$ent-&#62;{&#39;speciesid&#39;}]);
   # Could reduce / optimize change to bare minimum:
   my %change = (&#39;limbcnt&#39; =&#62; 4);
   print(&#34;Reduce property value on $spid\n&#34;);
   $shp-&#62;update(\%change, [$spid]);
   # Later ... (species dies extinct ?)
   #$shp-&#62;delete([$spid]);
   
   # Test if we need to insert / update (based on presence in DB)
   my $id = 5987;
   my $invals = {&#39;name&#39; =&#62; &#39;Crow&#39;, &#39;limbcnt&#39; =&#62; 4, &#39;family&#39; =&#62; &#39;birds&#39;};
   print(&#34;Test Presence of Animal &#39;$id&#39;\n&#34;);
   if ($shp-&#62;exists([$id])) {$shp-&#62;update($invals, [$id]);}
   else {$shp-&#62;insert($invals);}
   
   ##### Easy loading of sets / collections
   # Load all the animals
   my $animarr = $shp-&#62;loadset();
   print(&#34;All Animals: &#34;.Dumper($animarr).&#34;\n&#34;);
   # Load only mammals (by filter)
   my $mammarr = $shp-&#62;loadset({&#39;family&#39; =&#62; &#39;mammal&#39;});
   print(&#34;Mammals: &#34;.Dumper($mammarr).&#34;\n&#34;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Allow DB Persistence operations (insert(), load(), update(), delete(), exists()) on a plain old hash (unblessed or blessed) without writing classes, persistence code or SQL.</p>

<p>Optionally StoredHash allows your classes to inherit peristence capability from StoredHash allowing your objects to call StoredHash persistence methoda via object directly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GENERAL_INFO_ON_StoredHash_PERSISTENCE"
>GENERAL INFO ON StoredHash PERSISTENCE</a></h1>

<ul>
<li>Connection is stored in persister. Thus there is no need to pass it as parameter to persister methods.</li>

<li>Composite keys are supported by StoredHash. Because of this id values are passed in array. Id values must be ordered the same as their attribute names suring construction (as passed in &#39;pkey&#39; construction parameter).</li>

<li>Some persistence methods support &#39;attrs&#39; parameter. This means &#34;partial attributes&#34; or &#34;only these attributes&#34; whatever the direction is persistence operation is. Examples: load(): load only these attributes, update(): update only these attributes, etc.</li>

<li>StoredHash is not validating the hash keys / attribute (or &#39;attrs&#39; parameter above) against these attributes actually existing in DB schema. Caller of persistence methods is responsible validating the &#34;fit&#34; of hash to a schema.</li>
</ul>

<p>Above principles are consistent across persistence methods. These details will be not repeated in method documentation.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp_=_StoredHash-&#62;new(%opts);"
>$shp = StoredHash-&#62;new(%opts);</a></h2>

<p>Create new instance of StoredHash Persister.</p>

<p>Keyword parameters in %opts:</p>

<ul>
<li>&#39;pkey&#39; - array (ref) to reflect the identifying attrtibute(s) of entry (e.g. single attr for numeric sequential ids, multiple for composite key)</li>

<li>&#39;dbh&#39; - DBI connection to database (optional). Not passing &#39;dbh&#39; makes methods insert/update/load/delete return the SQL query only (as a string)</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;errstr($v)"
>$shp-&#62;errstr($v)</a></h2>

<p>Access error string that method may leave to object. Notice that many methods throw exception (by die()) with error message rather than leave it within object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;insert($e)"
>$shp-&#62;insert($e)</a></h2>

<p>Store entry %$e (hash) inserting it as a new entry to a database.</p>

<p>Returns an array of ID values for the entry that got stored (array of one element for numeric primary key, multiple for composite key).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;update($e,_$ids,_%opts);"
>$shp-&#62;update($e, $ids, %opts);</a></h2>

<p>Update an existing entry by ID(s) ($ids) in the database with values in hash %$e.</p>

<p>Return true for success, false for failure (direct $ok values from underlying $sth-&#62;execute() for &#39;autoid&#39; =&#62; 1 ),</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;delete($ids)_OR_$shp-&#62;delete($filter)"
>$shp-&#62;delete($ids) OR $shp-&#62;delete($filter)</a></h2>

<p>Delete an entry from database by passing one of the following:</p>

<ul>
<li>$ids - array with ID(s) for entry to be deleted (the usual use-case)</li>

<li>$filter - a hash with a where filter condition to delete by.</li>
</ul>

<p>Note that passing $filter haphazardly can cause massive destruction. Try to stick with passing $ids.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;exists($ids)"
>$shp-&#62;exists($ids)</a></h2>

<p>Test if an entry exists in the DB table with ID values passed in @$ids (array). Returns 1 (entry exists) or 0 (does not exist) under normal conditions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;load($ids)"
>$shp-&#62;load($ids)</a></h2>

<p>Load entry from DB table by its IDs passed in @$ids (array, single id typical sequece autoid pkey, multiple for composite primary key).</p>

<p>Entry will be loaded from single table passed at construction (never as result of join from multiple tables). Return entry as a hash (ref).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;loadset($filter,_$sort,_%opts);"
>$shp-&#62;loadset($filter, $sort, %opts);</a></h2>

<p>Load a set of Entries from persistent storage. Optionally provide simple &#34;where filter hash&#34; ($filter), whose key-value criteria is ANDed together to form the filter. Allow attibutes (in $sort, arrayref) to define sorting for entry set. Allow %opts to contain &#39;attrs&#39; (arrayref) to explicitly to define ettributes to load for each entry. Return set / collection of entries as array of hashes (AoH).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;cols(%opts)"
>$shp-&#62;cols(%opts)</a></h2>

<p>Sample Column names from (current) DB table. Return (ref to) array with field names in it.</p>

<p>%opts may contain KW parameter &#39;full&#39; to get full DBI column_info() structure (See DBI for details).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;count($filter)"
>$shp-&#62;count($filter)</a></h2>

<p>Get Count of all or a filtered set of entries (by optional $filter) in table. Return (scalar) count of entries.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERNAL_METHODS"
>INTERNAL METHODS</a></h1>

<p>These methods you should not need working on the high level. However for the curious they are outlined here.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="@pkv_=_$shp-&#62;pkeyvals($e)"
>@pkv = $shp-&#62;pkeyvals($e)</a></h2>

<p>Return Primary key values (as &#34;real&#34; array, not ref to one) from hash %$e. undef values are produced for non-existing keys. Mostly used for internal operations (and possibly debugging).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$shp-&#62;whereid($pkvals);"
>$shp-&#62;whereid($pkvals);</a></h2>

<p>Generate SQL WHERE Clause for update() (or delete() or load() or exists()) based on primary keys of current (table) type. Return WHERE clause with id-attribute(s) and placeholder(s) (idkey = ?, ...), without the WHERE keyword. Mostly called for internal operations. You should not need this.</p>

<!-- end doc -->

</body></html>
